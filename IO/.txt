Работа с файлами


Разделяется на:
 Взаимодействие с файловой системой: 
 поиск навигация копирование перенос удаление файлов и папок
 использование файлов для хранения информации
	сериализация(сохранение объектоов и их коллекций)


Сохранение информации в файле
большинство средств для работы с файлами находятся в System.IO

StreamWriter - класс для записи в файл

Навигация, поиск, список


!При задании имен файла часто используют @ перед строкой 
@"" - цитирование, строка как есть, не заменяется на спец символы '\n'

"Hell\n" - Hell перевод строки
@"Hell\n" - Hell\n == "Hell\\n"


"C:\users\"

System.IO.File - набор статических методов для работы с файлами
System.IO.Directory - набор статических методов для работы с директориями

Directory.EnumerateFiles возвращает коллекцию имен файлов
Directory.GetFiles возвращает массив имен

Коллекция - следующий элемент извлекается во время запроса
Массив - сразу получает все имена



Сериализация

от англ serial - последовательный 
процесс представления обьекта в виде строки, по которой 
этот объект может быть одноазачно восстановлен
Наиболее распространенные задачи сериализации:

 сохранение
 передача по сети


В С# наиболее популярны следующие технологии:
Бинарная сериализация - устаревшая/не рекомендуется
требует протокола Stream/FileStream
требует атрибута [Serializable] для классов


XML сериализация 
может работать с StreamReader , StreamWriter
сериализует только обьекты public классов
при создании сериализатор привязывается к типу данных,
в файл информация о типе не сохраняется
атрибут Serializable не требуется
НЕ сериализует Dictionary


JSON serialization 
реализована статическими методами
работает со строками, их сохранять / читать нужно отдельно


сераиализует только свойства
в .NET5+ можно включить сериализацию полей
атрибутом  [JsonInclude]
private свойства не сериализуются
сериализует Dictionary





LINQ

Language Integrated Queries
Запросы средствами языка

Есть две формы LINQ : запросы и методы(расширения)


using System.Linq;

LINQ применяется к коллекциям IEnumerable
Методы приемают лямбды или делегаты
параметром метода является элемент коллекции
метод LINQ возвращает новую коллекцию

Ряд методов - теминальные возвращают значние

Регулярные выражения 

Язык работы со строками

проверка по шаблону
поиск и замена
разбиение


Язык на спецсимволах
\d - digit
\D - non digit
\s - space
\S - non space
\w - word
\W - non word
. - один любой символ

[abc] - содержит a b или с
[^abc] - содержит содержит a b или с

{3} - ровно 3
{3,5} - от 3 до 5
{3,} - от 3 и более


\d{3} - 3 цифры подряд 123+ 1234+ 12-

\d+\.\?\d* - одна и более цифр точка есть или нет цифра{0,+бесконечность}
[a-z] - диапазон от а до z;
[0-9a-f] - HEX-цифра

() - границы группы

^ - начало строки
$ - конец строки



SOLID


пять принципов, рекомендованных при проектировании ООП программ

S - Single responsibility principle (принцип единственной ответственности)
O - Open-Close principle 
L - Liskov substitution principle - принцип заменяемости Лисков 
I - Interface segregation principle - принцип разделения интерфейсов
D - Dependency Injection principle - принци инверсии управления

	


S (SRP)

Один обьект должен решать одну задачу
задача одна - не нагружать другими задачами
задача решается - все что нужно содержится в объекте

Плохо:                                Лучше: 

Helper{									Hasher{						Saver{				Validator{

	CreateHash()						CreateHash()				SaveToFile()		Validator();
	SaveFile()
	ValidForm()
}										}							}					}



O (OCP) 

Классы закрыты для изменений, но открыты для дополнения 
Обновления, доработки (кроме исполнения ошибок) должны реализовываться в виде 
дополнений, а не изменения работающего кода 
=> простота отмены изменений
Плохо:
переписывать код с учетом новых требований 
Лучше:
создать класс наследник либо дополнить его новыми методами


L (LSP)

При замене класса на наследника не должно быть проблем
Если алгортм работает с классом С, то он должен нормально 
работать с любым наследником класса С
Корелирует с ОСР, наследник не должен переопределять поведение
базового класса, только расширять не дополнять его

С {Print {cw()}}

Плохо:										Лучше:
B:C{Print{return string}}					B:C{Print {base.Print, other}}


I (ISP)

Лучше создавать интерфейсы минимально возможного наполнения
не использовать нагруженные интерфейсы

Аналогия: разъем видео + звук /раздельно видио и звук

Плохо:								Лучше:														

IPrintable{							IConsolePrintable{PrintConsole}
	PrintConsole{}					IGdcPrintable{PrintGDC}
	PrintGDC{}						IPDFPrintable{PrintPDF}
	PrintPDF{}
}



D (DIP) / IoC

Програмирование ведется на уровне интерфейсов (а не конкретных реализаций)
централизация создание общих обектов (на уровне контейнера зависимостей)

Плохо:								Лучше
Obj1{hasher = new Hasher;}			Obj1{[Dependency] hasher}
Obj2{hasher = new Hasher;}			Obj2{[Dependency] hasher}








SOLID

D:
Inversion of control / Dependency Injection principle

Контейнер зависимостей - можно представить как словарь в котором 
типу сопоставлен обьект, например типу Random обьект rnd

При запросе сущности определенного типа возвращается ее обьект
либо выбрасывается исключение (из за отсутствия)


Контейнер поддерживает функции:

	Регистрации - регистрация ключей словаря (типоы)
	Разрушения - выборки всех необходимых обьектов по заданным типам
	Разрушения - управление жизненным циклом зарегестрированных обьектов


На примере контейнера Unity

0. Установить пакет
1. Описываем и создаем контейнер
2. Регистрируем типы, и или обьекты

container.RegisterInstance<Random>(new Random());		//объект создается сразу
container.RegisterType<Greeter>();                     // создает обьект толко когда было обращение

3. Описываем зависимости
4. Создание объектов через контейнер


Обобщенное программирование (Generic)

Классы:
Получть числа посчитать среднее
Проблма: неизвестно кол-во и тип данных


ООП

Интерфейсы
INumber{Add, Div}
IntNumber
FloatNumber
Логика(INumber)
Имплементация(IntNumber)


ОП
Number<T>{Add,Div}


Логика (Number<T>)
Имплементация (Number<T>)

C++ - Number<T> - подстановка (вместо Т int)
расширение обьект содержаищй информацию

С# - Number<T> - Т как обьект Получение информации об обьекте
называют обьектной рефлексией


Методы

var x = MakeRandom<int>();
var y = MakeRandom<int>(100,500);
var z = MakeRandom<float>();

var obj = MakeInstance<MyClass>();


Управление рессурсами
Жизненный цикл объектов, финализатор
Сборка мусора - управление памятью
Неуправляемые рессурсы IDisposable

Жизненный цикл обьекта
создание
Выделение памяти
инициализация

использование
оптимизация

удаление
финализация 
освобождение памяти

задачи обеспечения жизненного цикла обьектов исполняются модулем .NET - GC
(Garbabe Collector)

GC переодически вызывается метод GC.Collect();
По нашим наблюдениям 
при заполнении 8 - 24 - 75 - 240 мб
Есть возможность принудительно  запустить сборку
вызвав GC.Colect();


Поколения обьектов
Когда обьект создается ему присваивается поколение 0
При запуске GC происходит пересмотр поколений 
ненужные объекты удаляются (на которых нет ссылок)
те которые не удалились оптиимзируются и становятся поколением 1

при вызове GC.Collect(); можно указать с каким поколением работать
GC.Collect(0); - работа с нулевым поколением

Термие деструктор заменен на финализатор,
соответствует деструктору - не факт, что финализатор вообще будет вызван
Финализатор запускается сборщикоом мусора при удалении объекта в том числе и при принудительном
Для предотвращения двойной финализации которую вызвали мы и автоматической
используют инструкцию GC.SuppressFinalize(this)	

Неуправляемые ресурсы (обьекты) 
Это рессурсы связанные с операционной системой (ОС) - файлы, сокеты,
подключения к БД потоки Stream, мьютекс и тд
Эти объекты содержат ресурсы, зарегистрированые в системе и GC не может
посылать запросы на освобождение таких рессурсов

Чтобы освобождать такие рессурсы рекомендуется использовать интерфейс IDisposable












