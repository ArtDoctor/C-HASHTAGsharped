.NET C#
Основы

Новый проект (отличия от С++)

1. using - это аналог using namespace 
(не путать с include)
подключаемые модули делятся на несколько групп:
 Зависимости (DLL)
 Внешние пакеты (NuGet)


2 Пространство имен - Класс статич. Main 
разрешены 2 перегрузки 
Main()
Main(string[] args)


3. Console - класс с функциями консольного окна

--------------------------------

Типы данных
для удобства некоторым типам даны псевдонимы 
int - System.Int32
string - System.String


В С# (.NET) типы данных делятся на значимые(Value) и ссылочные(Reference)
Ссылочные типы ведут себя как указатели в С++
требуется new
может принимать null
при присваивании создается ссылка на тот же объект(семантика переноса)
Пользовательские ссылочные типы создаются через class
Значимые типы:
доступны после объявления (не нужно new)
не можеьт быть null
при присваивании - значения копируются

Пользовательские значимые типы создаются через struct

Вопрос: как себя поведет 
TypeStruct x = new TypeStruct();

а) будет создана "x"
б) будет создана анонимная структура TypeStruct
в) из анонимной структуры все поля скопирются в "x"


TypeClass y = new TypeClass();
а) будет создана переменная "y" как ссылка на TypeClass cо значением null
б) будет создан анонимные класс TypeClass - объект
в) ссылка (адрес) на объект будет сохранена в "y"

кросплатформенность управляемость 

Платформа: управуляемость
идея платформы - быть "между кодом и исполнителем" - позволяет
реализовать управляемость - дополнительный контроль
- управляемый код: код на IL (MSIL), выполняющийся только через платформу
неуправляемый код? обычные EXE, выполняющиеся сразу исполнителем
Возможен ли гибрид? Соединение управляемого кода и не управляемого?
Да, при использовании DLL неуправляемого типа (в т.ч. системных)


Управляемая память (ресурсы) - контроль на уровне платформы за ресурсами (в т.ч. за утечкой памяти)
Есть ли не управляемая память? Да память выделеная в обход платформы.
Как такое возможно?
а) из неуправляемого кода (подключенного из DLL)
б) от самих системных функций(например в хуках передается адресс структуры с данными о событии.
Очевидно, эта структура находится в неуправляемой памяти, так как создается ОС)

Передача данных между управляемой и не управляемой памятью называется маршализация, за нее отвечает класс Marshal
Все ли ресурсы созданные из управляемого кода являются управляемыми? Нет. Неуправляемыми являются ресурсы созданые ОС
(имеющие системные дескрипторы) файлы (открытые)сокеты, подключения
Класическим признаком является реализация интерфейса IDisposable(наличие метода Dispose)

Для таких обьектов рекомендуется использовать блок using:
using (File f = new File("f.f")){

........

}// по окончанию блока using Dispose вызывается автоматически


//аналог без using

File f = new File("f.f");
...f...
f.Dispose();
f = null;






