var - автоматическое определение типа (статическое - на этапе компиляции)
Существует динамический тип "dynamic", это совсем другое

Список инициализации: возможность указать значение полей обьекта при создании.
Заменяет собой необходимость создавать множество параметризированных конструкторов.

var c2 = new TypeC
{
            
    x = 20

};

object (System.Object) - родительские класс для всех ссылочных типов (то что наследуется по умолчанию)
Он задает для всех остальных типов методы:
ToString() - строковое представление. этот метод автоматически вызывается, если объект соединяется со строкой или прямо требуется его строка(Console.Write(obj))
Equals (object other) - результат сравнения двух обьектов

оператор проверки типа "is" : obj is Type - может ли obj быть приведенным к типу Type
Сам оператор приведения : obj as Type возвращает результат преобразования obj к типу Type(null если не возможно)
Существует также принудительное преобразование (Type)obj,оно годится для значимых типов
выбрасывает исключение, если преобразование невозможно


Console.WriteLine(
"You've entered {0}",str // - placeholder - местоподстановки
);                        // - 0 - индекс того что идет после ,

String str = Console.ReadLine(); - считывает строку до Enter '\n' в строку не попадает
int c = Console.Read(); - считывает один символ, возвращает код(int), срабатывает по нажатию Enter '\n' '\r' также считываются



ConsoleKeyInfo k = Console.ReadKey(); - считывет нажатую клавишу
Console.WriteLine(k.KeyChar);

ConsoleKeyInfo k = Console.ReadKey(true); // введеный символ не отображается



Неизменяемые строки и неправильный подход
while(...){... str+=char...}

Неизменяемые строки - не дают возможность изменения своего состава: str[1]='X' - не разрешено

Опреации сложения строк, в т.ч. += создают новые строки.
str += c-> new (str+c)=>str, старое значение str уходит в мусор.



Например считываем файл посимвольно и помещаем в строку.


пусть в файле 100 символов
str "" -> "1"->"12"->"123"->"1234"->....->"123...100"
все обьекты (str), кроме последнего станут мусором
?каков их обьем? 1+2+3+...+99=5000=>для формирования
строки из 100 символов потрачено 5к памяти
1000 символов -> (1000^2)/2 ~ 1M

решение этой проблемы - использование StringBuilder
накопитель фрагментов с последующим соединением


sb = new System.Text.StringBuilder();
while(..){... sb.Append()...}
str=sb.ToString();

Свойства в С# 
Свойства - это синтаксический сахар, скрывающий работу аксессоров за операцией присваивания:
obj.x = 10 ==> obj.setX(10)

Автосвойство - с классическим поведением аксессор

Коллекции (Generics)

List<T> - элластичный массив, аналог std::vector
Dictionary <T,T> аналог std::map, ассоциативный массив

























            




